#' Goodman-Bacon Decomposition
#'
#' bacon() is a function that perfroms the Goodman-Bacon decomposition for
#'  differences-in-differences with variation in treatment timing.
#'
#' @param formula a symbolic representation of the
#'  model to be fitted.
#' @param data a data.frame containing the variables in the model.
#' @param id_var character, the name of id variable for units.
#' @param time_var character, the name of time variable.
#' @param quiet logical, if TRUE does not print overal two-way fixed effects
#'  estimate or summary of 2x2 estimates by type.
#'
#' @author Evan Flack
#' @return data.frame of all 2x2 estimates and weights
#'
#' @examples
#' # Castle Doctrine -----------------------------------------------------------
#' decomp <- bacon(l_homicide ~ post,
#'                 data = bacon::castle,
#'                 id_var = "state",
#'                 time_var = "year")
#'
#' \donttest{
#'
#' ggplot(df_bacon) +
#'   aes(x = weight, y = estimate, shape = factor(type)) +
#'   labs(x = "Weight", y = "Estimate", shape = "Type") +
#'   geom_point()
#'
#'   }
#'
#'
#' @export
bacon <- function(formula,
                  data,
                  id_var,
                  time_var,
                  quiet = FALSE) {
  time <- NULL
  # Rename variables
  outcome_var <- as.character(formula)[2]
  treated_var <- as.character(formula)[3]

  data <- data[, c(id_var, time_var, outcome_var, treated_var)]
  colnames(data) <- c("id", "time", "outcome", "treated")
  # Check for NA observations
  nas <- sum(is.na(data))
  if (nas > 0) stop("NA observations")

  # Check for balanced panel
  bal <- stats::aggregate(time ~ id,  data = data, FUN = length)
  balanced <- ifelse(mean(bal$time == bal$time[1]) == 1, 1, 0)
  if (!balanced) stop("Unbalanced Panel")

  df_treat <- data[data$treated == 1, ]
  df_treat <- df_treat[, c("id", "time")]
  df_treat <- stats::aggregate(time ~ id,  data = df_treat, FUN = min)
  colnames(df_treat) <- c("id", "treat_time")
  data <- merge(data, df_treat, by = "id", all.x = T)
  data[is.na(data$treat_time), "treat_time"] <- 99999

  # First period in the panel
  first_period <- min(data$time)

  # create data.frame of all posible 2x2 estimates
  two_by_twos <- expand.grid(unique(data$treat_time),
                             unique(data$treat_time))
  colnames(two_by_twos) <- c("treated", "untreated")
  two_by_twos <- two_by_twos[!(two_by_twos$treated == two_by_twos$untreated), ]
  two_by_twos <- two_by_twos[!(two_by_twos$treated == 99999), ]
  two_by_twos <- two_by_twos[!(two_by_twos$treated == first_period), ]
  two_by_twos[, c("estimate", "weight")] <- 0

  for (i in 1:nrow(two_by_twos)) {
    treated_group <- two_by_twos[i, "treated"]
    untreated_group <- two_by_twos[i, "untreated"]
    data1 <- data[data$treat_time %in% c(treated_group, untreated_group), ]

    weight1 <- calculate_weights(data = data1,
                                 treated_group = treated_group,
                                 untreated_group = untreated_group)

    # Estimate 2x2 diff-in-diff
    estimate1 <- stats::lm(outcome ~ treated + factor(time) + factor(id),
                   data = data1)$coefficients[2]

    two_by_twos[i, "estimate"] <- estimate1
    two_by_twos[i, "weight"] <- weight1
  }

  # Rescale weights to 1
  total_weight <- sum(two_by_twos$weight)
  two_by_twos$weight <- two_by_twos$weight/total_weight
  # Classify estimate type
  two_by_twos$type <- ifelse(two_by_twos$untreated == 99999,
                             "Treated vs Untreated",
                             ifelse(two_by_twos$untreated == first_period,
                                    "Always Treated vs Later Treated",
                                    ifelse(two_by_twos$treated <
                                             two_by_twos$untreated,
                                           "Early vs Late", "Late vs Early")))

  overall_est <- stats::weighted.mean(two_by_twos$estimate,
                                      two_by_twos$weight)

  ret <- list(estimate = overall_est, decomp = two_by_twos,
              formula = formula)
  class(ret) <- "bacon"
  ret
}

#' Calculate Weights for 2x2 Grid
#'
#'  Calculated weights using:
#'  n_u - observations in untreated group,
#'  n_k - observations in earlier treated group,
#'  n_l - observations in later treated group,
#'  D_k - proportion of time the earlier treated group was treated,
#'  D_l - proportion of time the later treated group was treated.
#'
#' @param data a data.frame
#' @param treated_group the identifier of the treated group
#' @param untreated_group the identifier of the untreated group
#'
#' @return Scalar weight for 2x2 grid
calculate_weights <- function(data,
                              treated_group,
                              untreated_group){
  if (untreated_group == 99999) {
    # Treated vs untreated
    n_u <- sum(data$treat_time == untreated_group)
    n_k <- sum(data$treat_time == treated_group)
    n_ku <- n_k/(n_k + n_u)
    D_k <- mean(data[data$treat_time == treated_group, "treated"])
    V_ku <- n_ku*(1 - n_ku)*D_k*(1 - D_k)
    weight1 <- (n_k + n_u)^2*V_ku
  } else if (treated_group < untreated_group) {
    # early vs late (before late is treated)
    data <- data[data$time < untreated_group, ]
    n_k <- sum(data$treat_time == treated_group)
    n_l <- sum(data$treat_time == untreated_group)
    n_kl <- n_k/(n_k + n_l)
    D_k <- mean(data[data$treat_time == treated_group, "treated"])
    D_l <- mean(data[data$treat_time == untreated_group, "treated"])
    V_kl <- n_kl*(1 - n_kl)*(D_k - D_l)/(1 - D_l)*(1 - D_k)/(1 - D_l)
    weight1 <- ((n_k + n_l)*(1 - D_l))^2*V_kl
  } else if (treated_group > untreated_group) {
    # late vs early (after early is treated)
    data <- data[data$time >= untreated_group, ]
    n_k <- sum(data$treat_time == untreated_group)
    n_l <- sum(data$treat_time == treated_group)
    n_kl <- n_k/(n_k + n_l)
    D_k <- mean(data[data$treat_time == untreated_group, "treated"])
    D_l <- mean(data[data$treat_time == treated_group, "treated"])
    V_kl <- n_kl*(1 - n_kl)*(D_l/D_k)*(D_k - D_l)/(D_k)
    weight1 <- ((n_k + n_l)*D_k)^2*V_kl
  }
  return(weight1)
}

print.bacon <- function(object) {
  # Print two way FE estimate
  print(paste("Two-way FE Estimate =", object$estimate))
}

summary.bacon <- function(object) {
  # Print two way FE estimate
  print(paste0("Two-way FE estimate = ", object$estimate))
  # print summary of 2x2 estimates by type
  avg_est <- stats::aggregate(estimate ~ type, data = object$decomp, FUN = mean)
  colnames(avg_est) <- c("type", "avg_estimate")
  sum_weight <- stats::aggregate(weight ~ type, data = object$decomp, FUN = sum)
  avg_est_weight <- merge(avg_est, sum_weight, by = "type")
  print(avg_est_weight)
}
